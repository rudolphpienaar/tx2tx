= tx2tx Architecture

The architecture is now split into two first-class documents because the server and client solve different classes of problems with different invariants.

The server owns physical input truth, transition state, and remote routing policy. The client owns transport decode, local backend injection, and optional software cursor rendering. Treating them as one architecture obscures failure boundaries and encourages mixed-concern reasoning.

== Document Map

Server-side architecture and invariants:

- `docs/architecture-server.adoc`

Client-side architecture and invariants:

- `docs/architecture-client.adoc`

== System Topology

[source,text]
----
+------------------------------+        TCP/JSON         +------------------------------+
| SERVER MACHINE               | <---------------------> | CLIENT MACHINE               |
| (physical keyboard + mouse)  |                         | (event injection target)     |
|                              |                         |                              |
| capture -> context -> route  |                         | recv -> decode -> inject     |
+------------------------------+                         +------------------------------+
----

== Why This Split Matters

The dominant regressions in this codebase historically came from server-side state and transition coupling, not from client injection mechanics. A split architecture keeps causal analysis precise: server documents focus on correctness under context/ownership transitions, while client documents focus on deterministic application of received events.

== Current Status

The server runtime has been decomposed into focused modules (`server_runtime_coordinator`, `runtime_loop`, `transition_state`, `jump_hotkey_state`, `recovery_state`, `server_handshake`, `server_cli`, `server_logging`).

The client remains comparatively compact; its architecture is separated now to support independent evolution and testing criteria.
